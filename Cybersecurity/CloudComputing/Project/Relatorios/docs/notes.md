# Kubernetes Notes

## Benefits

- High availability
- Scalibility or High Performance
- Disaster Recovery

## Architecture

### Definitions

**Node** -> is a virtual or physical machine.
**Kubelet** -> A kubernetes process that makes it possible for the cluster to talk to each other and execute some tasks on nodes.
**Virtual Network** -> Creates one unified machine

### Explanations

We have one master node (control plane).
    - Connected to this master node we have worker nodes (mostly just referred to as "nodes")
    - Each worker node has a kubelet process running on it and containers.

Inside the master node (control plane), we have some services running on it:
    - **API Server**: To make interaction with k8s possible.
    - **Controller Manager**: Keeps track of what's happening inside the cluster
    - **Scheduler**: Responsible for scheduling containers on different nodes based on workload and the available server resources on each node.
    - **etcd**: Holds the current state on the k8s cluster. Configuration data, status data...

### Specifications

Control Plane Nodes are much more important than worker nodes, because if we lose the master node everything will be unavailable.
    - In this case, its important to keep more control planes backups, to avoid incidents of not being able to communicate with cluster.
Worker Nodes are much bigger and work intensive.

## Pod

A pod is the **smallest** unit in kubernetes and its an abstraction over container. It creates a layer on top of a container.
    - The reason that kubernetes does this is because they want to abstract away the container runtime so that you can replace them if you want to or you don't need to just work with docker or any certain container technology.
Usually, just 1 Application per Pod. The cases with 2+ containers inside a pod is just when you want to run an auxiliar container or external service inside a Pod.
Each Pod receives its own IP address (internal, not a public one), so my app can communicate with other Pods.
**Pods are Ephemeral** -> Means they can die really easily. If some error happens, a new Pod is created, with a new IP Address. (This is incovenient, because a database IP must be static)

## Service

A service is an IP Address that can be attached to each Pod. Even if a Pod dies, the service and the IP address will stay intact.
App should be accessible through browser -> We must create an **External Service**. They open communication for external sources, but obviously you wouldn't publicly provide your database to the external world, for those cases you can use an **Internal Service**. Internal Services are the default ones.

## Ingress

To create domains and avoid links like -> http://182.334.19.21:8080, we can use ingress to transform it into https://example.com.
The ingress acts like a middleware, that forwards the url to the correct service.

## Config Map

Acts like a global .env.
Its configurations data, example:

```hs
DATABASE_URL="postgresql://......
```

Config map is for non-confidential data only!

## Secret

Secret is just like Config Map but it's used to store secret data.

## Volume

If the database container or the pod with it gets restarted, the data would be gone. To avoid this, we use Volumes.
A volume is a persistent storage that is independent from the pod lifecycle. It can be a local storage or a remote storage (like AWS S3, GCP Storage, etc).

## Deployment

### Distributed System

A distributed system is a system where multiple computers work together to achieve a common goal.
In kubernetes, a deployment is a way to manage a distributed system.
If a server goes down, another server can take its place and continue serving the application -> This is called **Replication**.

In kubernetes, a deployment is a blueprint for creating pods and services. We can Scale up or down the number of replicas.
Its an abstraction over pods.

Databases can't be replicated via Deployments, because databases have state. For databases, we use Stateful Sets, to avoid data inconsistencies.

## Stateful Sets

Stateful Sets are used to manage stateful applications, like databases.
However, deploying stateful sets is more complex than deployments, because we need to ensure data consistency and avoid split-brain scenarios.
Databases are often hosted outside the kubernetes cluster, to avoid these complexities.

---

## Configuration Files

Each kubernetes object (Pod, Service, Deployment, etc) is defined in a YAML or JSON file.
They have 4 parts:

- **apiVersion**: The version of the kubernetes API.
- **kind**: The type of object (Pod, Service, Deployment, etc).
- **metadata**: The name and labels of the object.
- **spec**: The specifications of the object (containers, ports, replicas, etc).

Also, each configuration file has a status section, but its automatically generated by kubernetes.
They check the desired state vs the current state of the object. (To ensure everything is working as expected).
    - This status data is present inside etcd. **Etcd** holds the current status of any K8s component.

Example of a Pod configuration file:

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: my-pod
spec:
  containers:
    - name: my-container
      image: my-image
      ports:
        - containerPort: 80
```

## Commands

### Check Nodes

```sh
kubectl get nodes
```

### Check Pods

```sh
kubectl 
```
